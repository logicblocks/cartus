<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Getting Started</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Cartus</span> <span class="project-version">0.1.10</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="getting-started.html"><div class="inner"><span>Getting Started</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cartus</span></div></div></li><li class="depth-2 branch"><a href="cartus.cambium.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cambium</span></div></a></li><li class="depth-2 branch"><a href="cartus.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2"><a href="cartus.test.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>test</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#getting-started" name="getting-started"></a>Getting Started</h1>
<p><code>cartus</code> is a structured logging abstraction for logging data rich events with support for multiple logging backends, currently including:</p>
<ul>
  <li>a test logger for collecting logs in memory and asserting against  them; and</li>
  <li>a <a href="https://cambium-clojure.github.io/"><code>cambium</code></a> logger for logging  out via <a href="http://www.slf4j.org/"><code>SLF4J</code></a> and  <a href="http://logback.qos.ch/"><code>logback</code></a>.</li>
</ul>
<p><code>cartus</code> is heavily inspired by <a href="https://juxt.pro/blog/logging">JUXT’s blog post on logging</a> which recommends treating the logger as an injectable dependency like any other. This brings a number of benefits:</p>
<ul>
  <li>Testing for log events becomes easy, since the logger implementation can be  switched out for one more amenable to testing.</li>
  <li>More generally, different logging backends can be supported in different  contexts.</li>
  <li>Since the logger is passed as an explicit dependency, it can be transformed  in various ways, such as by adding context to all log events or filtering log  events to only those of a certain set of types within a particular scope.</li>
</ul>
<h2><a href="#installation" name="installation"></a>Installation</h2>
<p>Add the following to your <code>project.clj</code> file:</p>
<pre><code class="clojure">[io.logicblocks/cartus.core "0.1.10"]
</code></pre>
<h2><a href="#configuring-a-backend" name="configuring-a-backend"></a>Configuring a backend</h2>
<h3><a href="#the-backend" name="the-backend"></a>The <code>cartus.test/logger</code> backend</h3>
<p>The <a href="cartus.test.html#var-logger">cartus.test/logger</a> backend captures all logged events in memory in an atom, allowing your tests to assert that log events took place.</p>
<p>To install the <code>cartus.test/logger</code> backend, add the following to your <code>project.clj</code> file:</p>
<pre><code class="clojure">[io.logicblocks/cartus.test "0.1.10"]
</code></pre>
<p>To create a <code>cartus.test/logger</code>:</p>
<pre><code class="clojure">(require '[cartus.test])

(def logger (cartus.test/logger))
</code></pre>
<h3><a href="#the-backend" name="the-backend"></a>The <code>cartus.cambium/logger</code> backend</h3>
<p>The <a href="cartus.cambium.html#var-logger">cartus.cambium/logger</a> backend passes all logged events to <code>cambium</code> which in turn uses <a href="http://www.slf4j.org/"><code>SLF4J</code></a> and <a href="http://logback.qos.ch/"><code>logback</code></a> to log out the log event either in a plain text format or as JSON.</p>
<p>To install the <code>cartus.cambium/logger</code> backend, add the following to your <code>project.clj</code> file:</p>
<pre><code class="clojure">[io.logicblocks/cartus.cambium "0.1.10"]
</code></pre>
<p>Additionally, you must choose a codec and backend for <code>cambium</code>, which has implementations for plain text logging and for JSON logging. </p>
<p>To use plain text logs, add the following to your <code>project.clj</code> file:</p>
<pre><code class="clojure">[cambium/cambium.codec-simple "0.9.3"]
</code></pre>
<p>and add logback configuration (typically at <code>resources/logback.xml</code>) containing something like the following:</p>
<pre><code class="xml">&lt;configuration&gt;
  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
    &lt;encoder&gt;
      &lt;pattern&gt;
        %d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg { %mdc }%n
      &lt;/pattern&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;
  &lt;root level="debug"&gt;
    &lt;appender-ref ref="STDOUT" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<p>To use JSON logs, add the following to your <code>project.clj</code> file:</p>
<pre><code class="clojure">[cambium/cambium.codec-cheshire "0.9.3"]
[cambium/cambium.logback.json   "0.4.3"]
</code></pre>
<p>and add logback configuration (again, typically at <code>resources/logback.xml</code>) containing something like the following:</p>
<pre><code class="xml">&lt;configuration&gt;
  &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
    &lt;encoder class="ch.qos.logback.core.encoder.LayoutWrappingEncoder"&gt;
      &lt;layout class="cambium.logback.json.FlatJsonLayout"&gt;
        &lt;jsonFormatter class="ch.qos.logback.contrib.jackson.JacksonJsonFormatter"&gt;
          &lt;prettyPrint&gt;true&lt;/prettyPrint&gt;
        &lt;/jsonFormatter&gt;
        &lt;timestampFormat&gt;yyyy-MM-dd'T'HH:mm:ss.SSS'Z'&lt;/timestampFormat&gt;
        &lt;timestampFormatTimezoneId&gt;UTC&lt;/timestampFormatTimezoneId&gt;
        &lt;appendLineSeparator&gt;true&lt;/appendLineSeparator&gt;
      &lt;/layout&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;
  &lt;root level="debug"&gt;
    &lt;appender-ref ref="STDOUT" /&gt;
  &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<p>For more details of configuring <code>cambium</code> backends, see the <a href="https://cambium-clojure.github.io/"><code>cambium</code> documentation</a>.</p>
<p>Once a <code>cambium</code> codec and backend has been configured, <code>cambium</code> must be initialised as the system starts up. This can be achieved with the following:</p>
<pre><code class="clojure">(require '[cartus.cambium])

(cartus.cambium/initialise)
</code></pre>
<p>See <a href="cartus.cambium.html#var-initialise">cartus.cambium/initialise</a> for more details on initialisation options.</p>
<p>Once <code>cambium</code> is initialised, to create a <code>cartus.cambium/logger</code>:</p>
<pre><code class="clojure">(def logger (cartus.cambium/logger))
</code></pre>
<h3><a href="#custom-backends" name="custom-backends"></a>Custom backends</h3>
<p>All <code>cartus.core</code> functions expect an implementation of the <a href="cartus.core.html#var-Logger">cartus.core/Logger</a> protocol. </p>
<p>For example, to create a naive <code>StdoutLogger</code> which prints all log events to the standard output stream as EDN:</p>
<pre><code class="clojure">(ns example.stdout
  (:require
   [cartus.core :as core]))

(defrecord StdoutLogger
  []
  core/Logger
  (log [_ level type context opts]
    (println 
      (merge {:level level
            :type type
            :context context}
        opts))))

(defn logger []
  (map-&gt;StdoutLogger {}))
</code></pre>
<h2><a href="#logging-events" name="logging-events"></a>Logging events</h2>
<p>Log events:</p>
<ul>
  <li>are logged at a specific <code>level</code>, typically one of <code>:trace</code>, <code>:debug</code>,  <code>:info</code>, <code>:warn</code>, <code>:error</code> or <code>:fatal</code>;</li>
  <li>have a <code>type</code>, expressed as a keyword, such as  <code>:some.namespace/some.event.type</code>;</li>
  <li>include a map of additional <code>context</code>, which can be deeply nested;</li>
  <li>optionally include a <code>message</code> giving a textual description of the event;</li>
  <li>optionally include an <code>exception</code> including more details of an error;</li>
  <li>optionally include a <code>meta</code> map, including any metadata at the point of  the call to the logger such as the line, column and  namespace of the call.</li>
</ul>
<p>To log events at each respective level, you can use the convenience macros <a href="cartus.core.html#var-trace">cartus.core/trace</a>, <a href="cartus.core.html#var-debug">cartus.core/debug</a>, <a href="cartus.core.html#var-info">cartus.core/info</a>, <a href="cartus.core.html#var-warn">cartus.core/warn</a>, <a href="cartus.core.html#var-error">cartus.core/error</a> and <a href="cartus.core.html#var-fatal">cartus.core/fatal</a>, which also capture metadata for the call site automatically: </p>
<pre><code class="clojure">(ns example.logging
  (:require
   [cartus.core :as log]
   [cartus.cambium]))

(cartus.cambium/initialise)

(def logger (cartus.cambium/logger))

(log/trace logger ::system.started 
  {:flags {:in-memory-database false
           :live-services false}})
; =&gt; 
; "{
;   \"timestamp\" : \"2020-07-18T16:59:36.625Z\",
;   \"level\" : \"TRACE\",
;   \"thread\" : \"nREPL-session-ea7676d2-b76c-44c4-bc2b-d1c2f8515c0b\",
;   \"ns\" : \"example.logging\",
;   \"line\" : 10,
;   \"column\" : 1,
;   \"flags\" : {
;     \"in-memory-database\" : false,
;     \"live-services\" : false
;   },
;   \"type\" : \"example.logging/system.started\",
;   \"logger\" : \"example.logging\",
;   \"message\" : \"example.logging/system.started\",
;   \"context\" : \"default\"
; }
; "

(log/info logger ::database.migrating
  {:target-schema-version 10})
; =&gt; 
; "{
;   \"timestamp\" : \"2020-07-18T17:00:54.954Z\",
;   \"level\" : \"INFO\",
;   \"thread\" : \"nREPL-session-ea7676d2-b76c-44c4-bc2b-d1c2f8515c0b\",
;   \"ns\" : \"example.logging\",
;   \"line\" : 32,
;   \"column\" : 1,
;   \"target-schema-version\" : 10,
;   \"type\" : \"example.logging/database.migrating\",
;   \"logger\" : \"example.logging\",
;   \"message\" : \"example.logging/database.migrating\",
;   \"context\" : \"default\"
; }
; "

(log/debug logger ::database.migrated
  {:current-schema-version 10 :elapsed-millis 568}
  {:message "Success!"})
; =&gt;
; "{
;   \"timestamp\" : \"2020-07-18T17:02:10.798Z\",
;   \"level\" : \"DEBUG\",
;   \"thread\" : \"nREPL-session-ea7676d2-b76c-44c4-bc2b-d1c2f8515c0b\",
;   \"ns\" : \"example.logging\",
;   \"line\" : 50,
;   \"current-schema-version\" : 10,
;   \"column\" : 1,
;   \"elapsed-millis\" : 568,
;   \"type\" : \"example.logging/database.migrated\",
;   \"logger\" : \"example.logging\",
;   \"message\" : \"Success!\",
;   \"context\" : \"default\"
; }

(log/error logger ::cache.connecting
  {:address "tcp://cache.example.com:3456"}
  {:exception (ex-info "Connection failed" {:timeout-millis 500})})
; =&gt;
; "{
;   \"timestamp\" : \"2020-07-18T17:03:13.756Z\",
;   \"level\" : \"ERROR\",
;   \"thread\" : \"nREPL-session-ea7676d2-b76c-44c4-bc2b-d1c2f8515c0b\",
;   \"address\" : \"tcp://cache.example.com:3456\",
;   \"ns\" : \"example.logging\",
;   \"line\" : 69,
;   \"column\" : 1,
;   \"type\" : \"example.logging/cache.connecting\",
;   \"logger\" : \"example.logging\",
;   \"message\" : \"example.logging/cache.connecting\",
;   \"context\" : \"default\",
;   \"exception\" : \"clojure.lang.ExceptionInfo: Connection failed\
; \\tat example.logging$eval6273.invokeStatic(form-init17428929335843016668.clj:3)\
; \\tat example.logging$eval6273.invoke(form-init17428929335843016668.clj:1)\
; \\tat clojure.lang.Compiler.eval(Compiler.java:7177)\
; \\tat clojure.lang.Compiler.eval(Compiler.java:7132)\
; \\tat clojure.core$eval.invokeStatic(core.clj:3214)\
; \\tat clojure.core$eval.invoke(core.clj:3210)\
; \\tat nrepl.middleware.interruptible_eval$evaluate$fn__3914.invoke(interruptible_eval.clj:91)\
; \\tat clojure.main$repl$read_eval_print__9086$fn__9089.invoke(main.clj:437)\
; \\tat clojure.main$repl$read_eval_print__9086.invoke(main.clj:437)\
; \\tat clojure.main$repl$fn__9095.invoke(main.clj:458)\
; \\tat clojure.main$repl.invokeStatic(main.clj:458)\
; \\tat clojure.main$repl.doInvoke(main.clj:368)\
; \\tat clojure.lang.RestFn.invoke(RestFn.java:1523)\
; \\tat nrepl.middleware.interruptible_eval$evaluate.invokeStatic(interruptible_eval.clj:84)\
; \\tat nrepl.middleware.interruptible_eval$evaluate.invoke(interruptible_eval.clj:56)\
; \\tat nrepl.middleware.interruptible_eval$interruptible_eval$fn__3940$fn__3944.invoke(interruptible_eval.clj:155)\
; \\tat clojure.lang.AFn.run(AFn.java:22)\
; \\tat nrepl.middleware.session$session_exec$main_loop__4041$fn__4045.invoke(session.clj:190)\
; \\tat nrepl.middleware.session$session_exec$main_loop__4041.invoke(session.clj:189)\
; \\tat clojure.lang.AFn.run(AFn.java:22)\
; \\tat java.lang.Thread.run(Thread.java:748)\
; \"
; }
; "
</code></pre>
<p>Alternatively, you can use the <code>cartus.core/log</code> function from <a href="cartus.core.html#var-Logger">cartus.core/Logger</a> to log directly, giving full control over all aspects of the log event:</p>
<pre><code class="clojure">(ns example.logging
  (:require
   [cartus.core :as log]
   [cartus.cambium]))

(cartus.cambium/initialise)

(def logger (cartus.cambium/logger))

(log/log logger :info ::system.started
  {:flags {:in-memory-database false
             :live-services false}}
  {:meta {:line 10 :column 20 :ns (find-ns 'example.other)}})
; =&gt;
; "{
;   \"timestamp\" : \"2020-07-18T17:35:50.896Z\",
;   \"level\" : \"INFO\",
;   \"thread\" : \"nREPL-session-ea7676d2-b76c-44c4-bc2b-d1c2f8515c0b\",
;   \"ns\" : \"example.other\",
;   \"line\" : 10,
;   \"column\" : 20,
;   \"flags\" : {
;     \"in-memory-database\" : false,
;     \"live-services\" : false
;   },
;   \"type\" : \"example.logging/system.started\",
;   \"logger\" : \"example.other\",
;   \"message\" : \"example.logging/system.started\",
;   \"context\" : \"default\"
; }
; "
</code></pre>
<p>Note that in the case you use <code>cartus.core/log</code> directly, no metadata is captured so metadata must be provided explicitly.</p>
<h2><a href="#applying-transformations-to-loggers" name="applying-transformations-to-loggers"></a>Applying transformations to loggers</h2>
<p>Since <code>cartus.core</code> functions accept the logger as an explicit dependency, you can easily apply transformations to the logger as it is passed down through function calls. This allows additional behaviour to be added to a logger in a scoped manner, irrespective of backend used.</p>
<h3><a href="#setting-logger-context" name="setting-logger-context"></a>Setting logger context</h3>
<p>To add logger context to a logger instance, use <a href="cartus.core.html#var-with-context">cartus.core/with-context</a>. This function returns a new logger which will merge the provided context map with the context map provided at log time, with the log time context taking preference:</p>
<pre><code class="clojure">(ns example.logging
  (:require
   [cartus.core :as log]
   [cartus.cambium]))

(cartus.cambium/initialise)

(def standard-logger (cartus.cambium/logger))
(def contextual-logger (cartus.core/with-context standard-logger
                        {:request-id 5 :user-id 15}))

(log/info contextual-logger ::service.requesting
  {:request-id 10 :endpoint-name "check"})
; =&gt;
; "{
;   \"timestamp\" : \"2020-07-18T17:51:35.862Z\",
;   \"level\" : \"INFO\",
;   \"thread\" : \"nREPL-session-ea7676d2-b76c-44c4-bc2b-d1c2f8515c0b\",
;   \"endpoint-name\" : \"check\",
;   \"ns\" : \"example.logging\",
;   \"line\" : 12,
;   \"user-id\" : 15,
;   \"column\" : 1,
;   \"request-id\" : 10,
;   \"type\" : \"example.logging/service.requesting\",
;   \"logger\" : \"example.logging\",
;   \"message\" : \"example.logging/service.requesting\",
;   \"context\" : \"default\"
; }
; "
</code></pre>
<h3><a href="#filtering-by-log-levels" name="filtering-by-log-levels"></a>Filtering by log levels</h3>
<p>To retain log events based on their level, use <a href="cartus.core.html#var-with-levels-retained">cartus.core/with-levels-retained</a>. This function returns a new logger which will drop any log events that do not match the specified criteria based on a couple of different variants as discussed below.</p>
<p>To retain log events having a level within a provided set of levels:</p>
<pre><code class="clojure">(ns example.logging
  (:require
   [cartus.core :as log]
   [cartus.cambium]))

(cartus.cambium/initialise)

(def standard-logger (cartus.cambium/logger))
(def filtered-logger (cartus.core/with-levels-retained standard-logger
                        #{:warn :error}))

(log/info filtered-logger ::service.requesting
  {:request-id 10 :endpoint-name "check"})
; =&gt; nothing logged

(log/warn filtered-logger ::service.slow
  {:latency-millis 5486})
; "{
;   \"timestamp\" : \"2020-07-19T15:21:42.436Z\",
;   \"level\" : \"WARN\",
;   \"thread\" : \"nREPL-session-796b74ce-6705-4cf7-a55c-d95b089b8b34\",
;   \"latency-millis\" : 5486,
;   \"ns\" : \"example.logging\",
;   \"line\" : 15,
;   \"column\" : 1,
;   \"type\" : \"example.logging/service.slow\",
;   \"logger\" : \"example.logging\",
;   \"message\" : \"example.logging/service.slow\",
;   \"context\" : \"default\"
; }
; "
</code></pre>
<p>To retain log events having a level greater than or equal to a specified level in severity:</p>
<pre><code class="clojure">(ns example.logging
  (:require
   [cartus.core :as log]
   [cartus.cambium]))

(cartus.cambium/initialise)

(def standard-logger (cartus.cambium/logger))
(def filtered-logger 
  (cartus.core/with-levels-retained standard-logger &gt;= :info))

(log/debug filtered-logger ::database.connection-pool.requesting
  {:timeout-millis 200})
; =&gt; nothing logged

(log/info filtered-logger ::database.querying
  {:query-name :find-user})
; "{
;   \"timestamp\" : \"2020-07-19T15:28:23.843Z\",
;   \"level\" : \"INFO\",
;   \"thread\" : \"nREPL-session-796b74ce-6705-4cf7-a55c-d95b089b8b34\",
;   \"query-name\" : "find-user",
;   \"ns\" : \"example.logging\",
;   \"line\" : 15,
;   \"column\" : 1,
;   \"type\" : \"example.logging/database.querying\",
;   \"logger\" : \"example.logging\",
;   \"message\" : \"example.logging/database.querying\",
;   \"context\" : \"default\"
; }
; "
</code></pre>
<p>The arity-3 version of <a href="cartus.core.html#var-with-levels-retained">cartus.core/with-levels-retained</a> accepts the operators <code>&gt;=</code>, <code>&gt;</code>, <code>=</code>, <code>&lt;</code> and <code>&lt;=</code>.</p>
<p>To ignore log events based on their level, use <a href="cartus.core.html#var-with-levels-ignored">cartus.core/with-levels-ignored</a>. This function returns a new logger which will drop any log events that match the specified criteria based on a couple of different variants as discussed below.</p>
<p>To ignore log events having a level within a provided set of levels:</p>
<pre><code class="clojure">(ns example.logging
  (:require
   [cartus.core :as log]
   [cartus.cambium]))

(cartus.cambium/initialise)

(def standard-logger (cartus.cambium/logger))
(def filtered-logger (cartus.core/with-levels-ignored standard-logger
                        #{:warn :error}))

(log/info filtered-logger ::service.requesting
  {:request-id 10 :endpoint-name "check"})
; =&gt;
; "{
;   \"timestamp\" : \"2020-07-19T17:35:12.894Z\",
;   \"level\" : \"INFO\",
;   \"thread\" : \"nREPL-session-d8857a81-72f5-41ce-a107-eaecc7b75805\",
;   \"request-id\" : 10,
;   \"endpoint-name\" : \"check\",
;   \"ns\" : \"example.logging\",
;   \"line\" : 12,
;   \"column\" : 1,
;   \"type\" : \"example.logging/service.requesting\",
;   \"logger\" : \"example.logging\",
;   \"message\" : \"example.logging/service.requesting\",
;   \"context\" : \"default\"
; }
; "

(log/warn filtered-logger ::service.slow
  {:latency-millis 5486})
; =&gt; nothing logged
</code></pre>
<p>To ignore log events having a level less than or equal to a specified level in severity:</p>
<pre><code class="clojure">(ns example.logging
  (:require
   [cartus.core :as log]
   [cartus.cambium]))

(cartus.cambium/initialise)

(def standard-logger (cartus.cambium/logger))
(def filtered-logger 
  (cartus.core/with-levels-ignored standard-logger &lt; :info))

(log/debug filtered-logger ::database.connection-pool.requesting
  {:timeout-millis 200})
; =&gt; nothing logged

(log/info filtered-logger ::database.querying
  {:query-name :find-user})
; "{
;   \"timestamp\" : \"2020-07-19T17:48:13.983Z\",
;   \"level\" : \"INFO\",
;   \"thread\" : \"nREPL-session-b8bbb4af-f967-49eb-8ef3-9ad8f93376e8\",
;   \"query-name\" : "find-user",
;   \"ns\" : \"example.logging\",
;   \"line\" : 15,
;   \"column\" : 1,
;   \"type\" : \"example.logging/database.querying\",
;   \"logger\" : \"example.logging\",
;   \"message\" : \"example.logging/database.querying\",
;   \"context\" : \"default\"
; }
; "
</code></pre>
<p>The arity-3 version of <a href="cartus.core.html#var-with-levels-ignored">cartus.core/with-levels-ignored</a> accepts the operators <code>&gt;=</code>, <code>&gt;</code>, <code>=</code>, <code>&lt;</code> and <code>&lt;=</code>.</p>
<h3><a href="#filtering-by-log-types" name="filtering-by-log-types"></a>Filtering by log types</h3>
<p>To retain log events based on their type, use <a href="cartus.core.html#var-with-types-retained">cartus.core/with-types-retained</a>. This function returns a new logger which will drop any log events not having a type in the provided set of types:</p>
<pre><code class="clojure">(ns example.logging
  (:require
   [cartus.core :as log]
   [cartus.cambium]))

(cartus.cambium/initialise)

(def standard-logger (cartus.cambium/logger))
(def filtered-logger (cartus.core/with-types-retained standard-logger
                        #{::order.rejected ::order.approved}))

(log/debug filtered-logger ::order.pending
  {:outstanding-steps [:payment]})
; =&gt; nothing logged

(log/info filtered-logger ::order.rejected
  {:reason :card-payment-failed})
; "{
;   \"timestamp\" : \"2020-07-19T18:56:22.674Z\",
;   \"level\" : \"INFO\",
;   \"thread\" : \"nREPL-session-5d899bb7-3d16-4d84-81e0-691fc2df2c66\",
;   \"reason\" : "card-payment-failed",
;   \"ns\" : \"example.logging\",
;   \"line\" : 15,
;   \"column\" : 1,
;   \"type\" : \"example.logging/order.rejected\",
;   \"logger\" : \"example.logging\",
;   \"message\" : \"example.logging/order.rejected\",
;   \"context\" : \"default\"
; }
; "
</code></pre>
<p>To ignore log events based on their type, use <a href="cartus.core.html#var-with-types-ignored">cartus.core/with-types-ignored</a>. This function returns a new logger which will drop any log events having a type in the provided set of types:</p>
<pre><code class="clojure">(ns example.logging
  (:require
   [cartus.core :as log]
   [cartus.cambium]))

(cartus.cambium/initialise)

(def standard-logger (cartus.cambium/logger))
(def filtered-logger (cartus.core/with-types-ignored standard-logger
                        #{::order.pending}))

(log/debug filtered-logger ::order.pending
  {:outstanding-steps [:payment]})
; =&gt; nothing logged

(log/info filtered-logger ::order.rejected
  {:reason :card-payment-failed})
; "{
;   \"timestamp\" : \"2020-07-19T18:57:23.682Z\",
;   \"level\" : \"INFO\",
;   \"thread\" : \"nREPL-session-5d899bb7-3d16-4d84-81e0-691fc2df2c66\",
;   \"reason\" : "card-payment-failed",
;   \"ns\" : \"example.logging\",
;   \"line\" : 15,
;   \"column\" : 1,
;   \"type\" : \"example.logging/order.rejected\",
;   \"logger\" : \"example.logging\",
;   \"message\" : \"example.logging/order.rejected\",
;   \"context\" : \"default\"
; }
; "
</code></pre>
<h3><a href="#applying-arbitrary-transformations" name="applying-arbitrary-transformations"></a>Applying arbitrary transformations</h3>
<p>More generally, a logger can be seen as a stream of log events. With this in mind, <code>cartus</code> supports transducers being applied to loggers. This allows arbitrarily complex transformations to be built up using Clojure’s existing transducer support.</p>
<p>For example, to remove events that contain sensitive information and then map all context keys to snake case before logging an event, you can use the following: </p>
<pre><code class="clojure">(ns example.logging
  (:require
   [clojure.string :as string]
   [clojure.walk :as walk]

   [cartus.core :as log]
   [cartus.cambium]))

(cartus.cambium/initialise)

(defn transform-keys
  [t coll]
  (let [f (fn [[k v]] [(t k) v])]
    (walk/postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) coll)))

(defn -&gt;camel-case [k]
  (keyword 
    (string/replace (name k) #"-(\w)"
      #(string/upper-case (second %1)))))

(def standard-logger (cartus.cambium/logger))
(def filtered-logger 
  (cartus.core/with-transformation standard-logger
    (comp 
      (filter #(not (contains? (:context %) :password)))
      (map #(assoc % :context (transform-keys -&gt;camel-case (:context %)))))))

(log/debug filtered-logger ::order.pending
  {:outstanding-steps [:payment]
   :line-items [:item-1 :item-2]})
; "{
;   \"timestamp\" : \"2020-07-23T08:51:14.165Z\",
;   \"level\" : \"DEBUG\",
;   \"thread\" : \"nREPL-session-86b79ffc-6ce9-43af-91a9-0b1de812e86c\",
;   \"lineItems\" : [\"item-1\",\"item-2\"],
;   \"ns\" : \"example.logging\",
;   \"line\" : 1,
;   \"column\" : 1,
;   \"outstandingSteps\" : [\"payment\"],
;   \"type\" : \"example.logging/order.pending\",
;   \"logger\" : \"example.logging\",
;   \"message\" : \"example.logging/order.pending\",
;   \"context\" : \"default\"
; }
; "

(log/info filtered-logger ::registration.in-progress
  {:password "super-secret"})
; =&gt; nothing logged
</code></pre>
<p>All other transformations in <a href="cartus.core.html">cartus.core</a> use the transducer support under the covers and can be used as examples when implementing your own.</p>
<h2><a href="#testing-for-log-events" name="testing-for-log-events"></a>Testing for log events</h2>
<p>With the help of the <a href="cartus.test.html#var-logger">cartus.test/logger</a> and <a href="cartus.test.html#var-events">cartus.test/events</a>, you can assert that log events occurred from your tests:</p>
<pre><code class="clojure">(ns example.subject
  (:require
   [cartus.core :as log]))

(defn +-with-logging [logger &amp; vals]
  (log/info logger ::summing.values {:values vals})
  (apply + vals))

(ns example.subject-test
  (:require
   [cartus.test :as log-test]
   
   [example.subject :as subject]))

(deftest logs-while-summing
  (let [logger (cartus.test/logger)]
    (is (= 6 (subject/+-with-logging logger 1 2 3)))
    (is (= [{:level   :info
             :type    :example.subject/summing.values
             :context {:values [1 2 3]}
             :meta    {:ns (find-ns 'example.subject)
                       :line 6
                       :column 3}}]
      (log-test/events logger)))))
</code></pre></div></div></div></body></html>